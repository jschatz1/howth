//! Bundle output emission.
//!
//! Generates the final bundled JavaScript from the module graph.

#![allow(clippy::redundant_else)]
#![allow(clippy::manual_is_ascii_check)]
#![allow(clippy::needless_lifetimes)]
#![allow(clippy::unnecessary_wraps)]
#![allow(clippy::manual_pattern_char_comparison)]

use super::graph::{ModuleGraph, ModuleId};
use super::treeshake::UsedExports;
use super::{BundleError, BundleOptions};
use crate::compiler::{CompilerBackend, SwcBackend, TranspileSpec};
use std::collections::HashSet;

/// Output format for the bundle.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum BundleFormat {
    /// ES Modules (import/export).
    #[default]
    Esm,
    /// CommonJS (require/module.exports).
    Cjs,
    /// IIFE (immediately invoked function expression).
    Iife,
}

/// Bundle output.
#[derive(Debug)]
pub struct BundleOutput {
    /// The bundled code.
    pub code: String,
    /// Source map (if enabled).
    pub map: Option<String>,
}

/// Emit a bundle from the module graph.
pub fn emit_bundle(
    graph: &ModuleGraph,
    order: &[ModuleId],
    options: &BundleOptions,
) -> Result<BundleOutput, BundleError> {
    emit_bundle_with_entry(graph, order, options, None)
}

/// Emit a bundle with a specific entry point (for code splitting).
pub fn emit_bundle_with_entry(
    graph: &ModuleGraph,
    order: &[ModuleId],
    options: &BundleOptions,
    entry_override: Option<ModuleId>,
) -> Result<BundleOutput, BundleError> {
    // Determine entry point
    let entry_id = entry_override.or_else(|| order.last().copied());

    // Compute used exports for tree shaking
    let used_exports = if options.treeshake {
        entry_id.map(|id| UsedExports::analyze(graph, id))
    } else {
        None
    };

    let mut output = String::new();

    // Bundle header
    output.push_str("// howth bundle\n");
    output.push_str("// Generated by howth v0.1.0\n\n");

    match options.format {
        BundleFormat::Esm => emit_esm(
            graph,
            order,
            options,
            used_exports.as_ref(),
            entry_id,
            &mut output,
        )?,
        BundleFormat::Cjs => emit_cjs(
            graph,
            order,
            options,
            used_exports.as_ref(),
            entry_id,
            &mut output,
        )?,
        BundleFormat::Iife => emit_iife(
            graph,
            order,
            options,
            used_exports.as_ref(),
            entry_id,
            &mut output,
        )?,
    }

    Ok(BundleOutput {
        code: output,
        map: None, // TODO: source map support
    })
}

/// Emit ESM bundle.
fn emit_esm(
    graph: &ModuleGraph,
    order: &[ModuleId],
    options: &BundleOptions,
    used_exports: Option<&UsedExports>,
    entry_id: Option<ModuleId>,
    output: &mut String,
) -> Result<(), BundleError> {
    // For ESM, we use a module registry pattern
    output.push_str("const __modules = {};\n");
    output.push_str("const __exports = {};\n\n");

    output.push_str("function __require(id) {\n");
    output.push_str("  if (__exports[id]) return __exports[id];\n");
    output.push_str("  const module = { exports: {} };\n");
    output.push_str("  __modules[id](module, module.exports, __require);\n");
    output.push_str("  __exports[id] = module.exports;\n");
    output.push_str("  return module.exports;\n");
    output.push_str("}\n\n");

    // Emit each module
    for &id in order {
        let module = graph.get(id).ok_or_else(|| BundleError {
            code: "BUNDLE_INTERNAL_ERROR",
            message: format!("Module {} not found in graph", id),
            path: None,
        })?;

        emit_module(id, module, graph, output, options, used_exports)?;
    }

    // Entry point execution
    if let Some(entry) = entry_id {
        output.push_str(&format!("\n// Entry point\n__require({});\n", entry));
    }

    Ok(())
}

/// Emit CJS bundle.
fn emit_cjs(
    graph: &ModuleGraph,
    order: &[ModuleId],
    options: &BundleOptions,
    used_exports: Option<&UsedExports>,
    entry_id: Option<ModuleId>,
    output: &mut String,
) -> Result<(), BundleError> {
    // Similar to ESM but with CommonJS wrapper
    emit_esm(graph, order, options, used_exports, entry_id, output)?;

    // Add module.exports for the entry
    if let Some(entry) = entry_id {
        output.push_str(&format!("\nmodule.exports = __exports[{}];\n", entry));
    }

    Ok(())
}

/// Emit IIFE bundle.
fn emit_iife(
    graph: &ModuleGraph,
    order: &[ModuleId],
    options: &BundleOptions,
    used_exports: Option<&UsedExports>,
    entry_id: Option<ModuleId>,
    output: &mut String,
) -> Result<(), BundleError> {
    output.push_str("(function() {\n");
    output.push_str("'use strict';\n\n");

    // Emit the ESM content inside IIFE
    let mut inner = String::new();
    emit_esm(graph, order, options, used_exports, entry_id, &mut inner)?;

    // Indent the inner content
    for line in inner.lines() {
        output.push_str("  ");
        output.push_str(line);
        output.push('\n');
    }

    output.push_str("})();\n");

    Ok(())
}

/// Emit a single module.
fn emit_module(
    id: ModuleId,
    module: &super::graph::Module,
    graph: &ModuleGraph,
    output: &mut String,
    _options: &BundleOptions,
    used_exports: Option<&UsedExports>,
) -> Result<(), BundleError> {
    output.push_str(&format!("// Module {}: {}\n", id, module.path));
    output.push_str(&format!(
        "__modules[{}] = function(module, exports, require) {{\n",
        id
    ));

    // Get the set of used exports for tree shaking
    let used_set: Option<HashSet<String>> = used_exports.and_then(|u| u.get_used(id).cloned());

    // Transform the source code with tree shaking info
    let transformed = transform_module(&module.source, &module.path, graph, used_set.as_ref())?;

    // Indent and emit
    for line in transformed.lines() {
        output.push_str("  ");
        output.push_str(line);
        output.push('\n');
    }

    output.push_str("};\n\n");

    Ok(())
}

/// Transform module source (transpile TS/JSX, rewrite imports).
fn transform_module(
    source: &str,
    module_path: &str,
    graph: &ModuleGraph,
    used_exports: Option<&HashSet<String>>,
) -> Result<String, BundleError> {
    // First, transpile TypeScript/JSX to JavaScript using SWC
    let transpiled = transpile_source(source, module_path)?;

    // Collect exports to emit at the end
    let mut pending_exports: Vec<String> = Vec::new();
    let mut result = String::new();

    for line in transpiled.lines() {
        let (transformed, export_stmts) =
            transform_line_with_exports(line, module_path, graph, used_exports)?;

        // Filter SWC-generated exports.xxx = xxx; statements based on tree shaking
        let filtered = filter_swc_export(&transformed, used_exports);
        if let Some(filtered_line) = filtered {
            result.push_str(&filtered_line);
            result.push('\n');
        }

        pending_exports.extend(export_stmts);
    }

    // Emit all pending exports at the end (only used ones)
    for export_stmt in pending_exports {
        result.push_str(&export_stmt);
        result.push('\n');
    }

    Ok(result)
}

/// Filter SWC-generated `exports.xxx = xxx;` statements based on tree shaking.
/// Returns None if the line should be removed, Some(line) otherwise.
fn filter_swc_export(line: &str, used_exports: Option<&HashSet<String>>) -> Option<String> {
    let trimmed = line.trim();

    // Check for SWC-generated export pattern: exports.xxx = xxx;
    if trimmed.starts_with("exports.") && trimmed.contains(" = ") {
        // Extract the export name: "exports.foo = foo;" -> "foo"
        if let Some(dot_end) = trimmed[8..].find(' ') {
            let export_name = &trimmed[8..8 + dot_end];

            // Check if this export is used
            match used_exports {
                None => return Some(line.to_string()), // No tree shaking, keep all
                Some(set) => {
                    if set.contains(export_name) || export_name == "default" {
                        return Some(line.to_string()); // Export is used, keep it
                    } else {
                        return None; // Export is unused, remove it
                    }
                }
            }
        }
    }

    Some(line.to_string())
}

/// Transpile TypeScript/JSX to JavaScript using SWC.
fn transpile_source(source: &str, path: &str) -> Result<String, BundleError> {
    let backend = SwcBackend::new();

    // Create a transpile spec
    let spec = TranspileSpec::new(path, "");

    match backend.transpile(&spec, source) {
        Ok(output) => Ok(output.code),
        Err(e) => Err(BundleError {
            code: "BUNDLE_TRANSPILE_ERROR",
            message: e.message,
            path: Some(path.to_string()),
        }),
    }
}

/// Transform a single line (basic import/export rewriting).
/// Returns (transformed_line, pending_exports_to_emit_later).
fn transform_line_with_exports(
    line: &str,
    module_path: &str,
    graph: &ModuleGraph,
    used_exports: Option<&HashSet<String>>,
) -> Result<(String, Vec<String>), BundleError> {
    let trimmed = line.trim();

    // Rewrite imports
    if trimmed.starts_with("import ") {
        return Ok((rewrite_import(line, module_path, graph), Vec::new()));
    }

    // Rewrite exports
    if trimmed.starts_with("export ") {
        let (transformed, exports) = rewrite_export_with_pending(line, used_exports);
        return Ok((transformed, exports));
    }

    // Pass through unchanged
    Ok((line.to_string(), Vec::new()))
}

/// Check if a specifier is a CSS file.
fn is_css_import(spec: &str) -> bool {
    std::path::Path::new(spec)
        .extension()
        .is_some_and(|ext| ext.eq_ignore_ascii_case("css"))
}

/// Check if a specifier is an asset file.
fn is_asset_import(spec: &str) -> bool {
    let asset_exts = [
        "png", "jpg", "jpeg", "gif", "svg", "webp", "ico", "avif", "woff", "woff2", "ttf", "otf",
        "eot", "json", "txt", "wasm",
    ];
    std::path::Path::new(spec)
        .extension()
        .is_some_and(|ext| asset_exts.iter().any(|e| ext.eq_ignore_ascii_case(e)))
}

/// Rewrite an import statement.
fn rewrite_import(line: &str, module_path: &str, graph: &ModuleGraph) -> String {
    // import { foo } from './bar' -> const { foo } = require(1)
    // import foo from './bar' -> const foo = require(1).default
    // import './bar' -> require(1)
    // import './style.css' -> (CSS injection, handled at bundle level)
    // import logo from './logo.png' -> const logo = './logo.abc123.png'

    let trimmed = line.trim();

    // Helper to resolve specifier to module ID or keep as string
    let resolve_require = |spec: &str| -> String {
        if let Some(id) = graph.resolve_specifier(module_path, spec) {
            format!("require({})", id)
        } else {
            // External or unresolved - keep as string
            format!("require('{}')", spec)
        }
    };

    // Side-effect import: import './foo'
    if let Some(rest) = trimmed.strip_prefix("import '") {
        if let Some(spec) = rest.strip_suffix("';") {
            // CSS import - generate empty statement (CSS is bundled separately)
            if is_css_import(spec) {
                return format!("/* CSS: {} */", spec);
            }
            return format!("{};", resolve_require(spec));
        }
    }
    if let Some(rest) = trimmed.strip_prefix("import \"") {
        if let Some(spec) = rest.strip_suffix("\";") {
            // CSS import - generate empty statement (CSS is bundled separately)
            if is_css_import(spec) {
                return format!("/* CSS: {} */", spec);
            }
            return format!("{};", resolve_require(spec));
        }
    }

    // Named imports: import { foo, bar } from './baz'
    if trimmed.contains('{') && trimmed.contains('}') && trimmed.contains(" from ") {
        // Extract the names and specifier
        if let Some(from_idx) = trimmed.find(" from ") {
            let imports_part = &trimmed[7..from_idx]; // after "import "
            let spec_part = &trimmed[from_idx + 6..].trim();
            let spec = spec_part.trim_matches(|c| c == '\'' || c == '"' || c == ';');

            return format!("const {} = {};", imports_part, resolve_require(spec));
        }
    }

    // Default import: import foo from './bar'
    if trimmed.contains(" from ") && !trimmed.contains('{') {
        if let Some(from_idx) = trimmed.find(" from ") {
            let name = trimmed[7..from_idx].trim(); // after "import "
            let spec_part = &trimmed[from_idx + 6..].trim();
            let spec = spec_part.trim_matches(|c| c == '\'' || c == '"' || c == ';');

            // Check for * as namespace import
            if name.starts_with("* as ") {
                let ns_name = name.strip_prefix("* as ").unwrap().trim();
                return format!("const {} = {};", ns_name, resolve_require(spec));
            }

            // Asset import: import logo from './logo.png'
            // Returns the asset URL (will be rewritten with hash at bundle time)
            if is_asset_import(spec) {
                return format!("const {} = '{}';", name, spec);
            }

            let req = resolve_require(spec);
            return format!("const {} = {}.default || {};", name, req, req);
        }
    }

    // Fallback: return as-is with a comment
    format!("/* TODO: transform */ {}", line)
}

/// Rewrite an export statement, returning the transformed line and pending exports.
/// Returns (transformed_line, vec_of_exports_to_emit_at_end).
/// If used_exports is Some, only exports in that set will be emitted.
fn rewrite_export_with_pending(
    line: &str,
    used_exports: Option<&HashSet<String>>,
) -> (String, Vec<String>) {
    let trimmed = line.trim();

    // Helper to check if an export is used
    let is_used = |name: &str| -> bool {
        match used_exports {
            None => true, // No tree shaking, all exports are used
            Some(set) => set.contains(name) || name == "default",
        }
    };

    // export default - always include (entry point API)
    if trimmed.starts_with("export default ") {
        let value = trimmed.strip_prefix("export default ").unwrap();
        let value = value.trim_end_matches(';');
        return (format!("exports.default = {};", value), Vec::new());
    }

    // export const/let/var
    if trimmed.starts_with("export const ")
        || trimmed.starts_with("export let ")
        || trimmed.starts_with("export var ")
    {
        let decl = trimmed.strip_prefix("export ").unwrap();
        let parts: Vec<&str> = decl.splitn(3, ' ').collect();
        if parts.len() >= 2 {
            let name = parts[1].trim_end_matches(['=', ':', ' ']);
            if is_used(name) {
                return (
                    decl.to_string(),
                    vec![format!("exports.{} = {};", name, name)],
                );
            } else {
                // Tree shake: include declaration but don't export
                return (decl.to_string(), Vec::new());
            }
        }
    }

    // export function
    if trimmed.starts_with("export function ") {
        let decl = trimmed.strip_prefix("export ").unwrap();
        if let Some(paren_idx) = decl.find('(') {
            let name = decl[9..paren_idx].trim(); // after "function "
            if is_used(name) {
                return (
                    decl.to_string(),
                    vec![format!("exports.{} = {};", name, name)],
                );
            } else {
                // Tree shake: include function but don't export
                return (decl.to_string(), Vec::new());
            }
        }
    }

    // export class
    if trimmed.starts_with("export class ") {
        let decl = trimmed.strip_prefix("export ").unwrap();
        let parts: Vec<&str> = decl.splitn(3, ' ').collect();
        if parts.len() >= 2 {
            let name = parts[1].trim_end_matches(|c: char| matches!(c, '{' | ' '));
            if is_used(name) {
                return (
                    decl.to_string(),
                    vec![format!("exports.{} = {};", name, name)],
                );
            } else {
                // Tree shake: include class but don't export
                return (decl.to_string(), Vec::new());
            }
        }
    }

    // export { foo, bar }
    if trimmed.starts_with("export {") {
        if let Some(end) = trimmed.find('}') {
            let names = &trimmed[8..end];
            let export_names: Vec<&str> = names.split(',').map(|s| s.trim()).collect();

            let mut export_stmts = Vec::new();
            for name in export_names {
                if name.contains(" as ") {
                    let parts: Vec<&str> = name.split(" as ").collect();
                    if parts.len() == 2 {
                        export_stmts.push(format!(
                            "exports.{} = {};",
                            parts[1].trim(),
                            parts[0].trim()
                        ));
                    }
                } else if !name.is_empty() {
                    export_stmts.push(format!("exports.{} = {};", name, name));
                }
            }
            return (String::new(), export_stmts); // Remove the export line, emit exports at end
        }
    }

    // Fallback
    (format!("/* TODO: transform export */ {}", line), Vec::new())
}

#[cfg(test)]
mod tests {
    use super::*;

    fn empty_graph() -> ModuleGraph {
        ModuleGraph::new()
    }

    #[test]
    fn test_rewrite_import_side_effect() {
        let graph = empty_graph();
        // CSS imports are handled separately (bundled CSS), not require'd
        assert_eq!(
            rewrite_import("import './styles.css';", "/test/file.ts", &graph),
            "/* CSS: ./styles.css */"
        );
    }

    #[test]
    fn test_rewrite_import_named() {
        let graph = empty_graph();
        assert_eq!(
            rewrite_import(
                "import { foo, bar } from './utils';",
                "/test/file.ts",
                &graph
            ),
            "const { foo, bar } = require('./utils');"
        );
    }

    #[test]
    fn test_rewrite_import_default() {
        let graph = empty_graph();
        assert_eq!(
            rewrite_import("import React from 'react';", "/test/file.ts", &graph),
            "const React = require('react').default || require('react');"
        );
    }

    #[test]
    fn test_rewrite_export_const() {
        let (decl, exports) = rewrite_export_with_pending("export const foo = 1;", None);
        assert_eq!(decl, "const foo = 1;");
        assert_eq!(exports, vec!["exports.foo = foo;"]);
    }

    #[test]
    fn test_rewrite_export_default() {
        let (result, exports) = rewrite_export_with_pending("export default App;", None);
        assert_eq!(result, "exports.default = App;");
        assert!(exports.is_empty());
    }

    #[test]
    fn test_tree_shaking_filters_unused() {
        let mut used = HashSet::new();
        used.insert("usedFn".to_string());

        // Used export should be included
        let (_, exports) = rewrite_export_with_pending("export function usedFn() {}", Some(&used));
        assert_eq!(exports, vec!["exports.usedFn = usedFn;"]);

        // Unused export should be filtered
        let (_, exports) =
            rewrite_export_with_pending("export function unusedFn() {}", Some(&used));
        assert!(exports.is_empty());
    }

    #[test]
    fn test_filter_swc_export() {
        let mut used = HashSet::new();
        used.insert("foo".to_string());

        // Used export - should be kept
        assert!(filter_swc_export("exports.foo = foo;", Some(&used)).is_some());

        // Unused export - should be removed
        assert!(filter_swc_export("exports.bar = bar;", Some(&used)).is_none());

        // Default always kept
        assert!(filter_swc_export("exports.default = App;", Some(&used)).is_some());

        // No tree shaking - all kept
        assert!(filter_swc_export("exports.bar = bar;", None).is_some());
    }

    #[test]
    fn test_tree_shaking_integration() {
        use crate::bundler::graph::Module;
        use crate::bundler::{Import, ImportedName};

        // Create a module graph with:
        // - entry.ts: imports only `add` from utils
        // - utils.ts: exports `add`, `subtract`, `multiply`
        let mut graph = ModuleGraph::new();

        // utils.ts - has three exports but only one is used
        let utils_module = Module {
            path: "/test/utils.ts".to_string(),
            source: r"
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }
export function multiply(a, b) { return a * b; }
"
            .to_string(),
            imports: Vec::new(),
            dependencies: Vec::new(),
            dynamic_dependencies: Vec::new(),
        };
        let utils_id = graph.add(utils_module);

        // entry.ts - only imports `add`
        let entry_module = Module {
            path: "/test/entry.ts".to_string(),
            source: r"
import { add } from './utils';
console.log(add(1, 2));
"
            .to_string(),
            imports: vec![Import {
                specifier: "./utils".to_string(),
                dynamic: false,
                names: vec![ImportedName {
                    imported: "add".to_string(),
                    local: "add".to_string(),
                }],
            }],
            dependencies: vec![utils_id],
            dynamic_dependencies: Vec::new(),
        };
        let entry_id = graph.add(entry_module);

        // Set up specifier resolution
        let mut dep_info = std::collections::HashMap::new();
        dep_info.insert(
            "/test/entry.ts".to_string(),
            vec![("./utils".to_string(), "/test/utils.ts".to_string(), false)],
        );
        graph.set_dependencies(&dep_info);

        // Analyze tree shaking
        let used_exports = UsedExports::analyze(&graph, entry_id);

        // Entry should have all exports used (it's the entry point)
        assert!(used_exports.all_used(entry_id));

        // Utils should only have `add` marked as used
        let utils_used = used_exports.get_used(utils_id);
        assert!(utils_used.is_some());
        let utils_set = utils_used.unwrap();
        assert!(utils_set.contains("add"));
        assert!(!utils_set.contains("subtract"));
        assert!(!utils_set.contains("multiply"));
    }
}
